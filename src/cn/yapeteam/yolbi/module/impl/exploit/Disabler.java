package cn.yapeteam.yolbi.module.impl.exploit;

import cn.yapeteam.yolbi.YolBi;
import cn.yapeteam.yolbi.event.Listener;
import cn.yapeteam.yolbi.event.impl.network.PacketReceiveEvent;
import cn.yapeteam.yolbi.event.impl.network.PacketSendEvent;
import cn.yapeteam.yolbi.event.impl.player.EntityActionEvent;
import cn.yapeteam.yolbi.event.impl.player.MotionEvent;
import cn.yapeteam.yolbi.event.impl.player.MoveEvent;
import cn.yapeteam.yolbi.module.Module;
import cn.yapeteam.yolbi.module.ModuleCategory;
import cn.yapeteam.yolbi.module.ModuleInfo;
import cn.yapeteam.yolbi.module.impl.movement.Speed;
import cn.yapeteam.yolbi.util.misc.TimerUtil;
import cn.yapeteam.yolbi.util.network.PacketUtil;
import cn.yapeteam.yolbi.util.world.WorldUtil;
import cn.yapeteam.yolbi.values.impl.BooleanValue;
import cn.yapeteam.yolbi.values.impl.ModeValue;
import cn.yapeteam.yolbi.values.impl.NumberValue;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.*;
import net.minecraft.network.play.server.S08PacketPlayerPosLook;

import java.util.ArrayList;

@ModuleInfo(name = "Disabler", category = ModuleCategory.EXPLOIT)
public class Disabler extends Module {
    private final ModeValue<String> mode = new ModeValue<>("Mode", "Watchdog inventory", "Watchdog inventory", "Watchdog strafe silent", "Pingspoof", "Specte", "Custom");

    private final BooleanValue strict = new BooleanValue("Strict", () -> mode.is("Watchdog strafe silent"), false);
    private final NumberValue<Integer> blinkTicks = new NumberValue<>("Blink ticks", () -> mode.is("Watchdog strafe silent"), 10, 3, 14, 1);

    private final NumberValue<Integer> delay = new NumberValue<>("Delay", () -> mode.is("Pingspoof"), 500, 50, 4000, 50);
    private final BooleanValue s08 = new BooleanValue("S08", () -> mode.is("Pingspoof"), false);

    private final BooleanValue balance = new BooleanValue("Balance", () -> mode.is("Custom"), true);
    private final BooleanValue noSprint = new BooleanValue("No Sprint", () -> mode.is("Custom"), false);
    private final BooleanValue noSneak = new BooleanValue("No Sneak", () -> mode.is("Custom"), false);

    private final BooleanValue silentTeleportAccept = new BooleanValue("Silent teleport accept", () -> mode.is("Custom"), false);
    private final NumberValue<Double> silentRange = new NumberValue<>("Silent range", () -> mode.is("Custom") && silentTeleportAccept.getValue(), 8.0, 0.25, 20.0, 0.25);

    private Speed speedModule;

    private final TimerUtil timer = new TimerUtil();

    private final ArrayList<Packet> packetsQueue = new ArrayList<>();

    private int groundSpoofTicks, ticks;

    private double motionX, motionZ;
    private double lastMotionX, lastMotionZ;

    private boolean blinking;

    public Disabler() {
        this.addValues(mode, strict, blinkTicks, delay, s08, balance, noSprint, noSneak, silentTeleportAccept, silentRange);
    }

    @Override
    public void onEnable() {
        groundSpoofTicks = ticks = 0;
    }

    @Override
    public void onDisable() {
        if (!packetsQueue.isEmpty()) {
            for (Packet packet : packetsQueue) {
                PacketUtil.sendPacketNoEvent(packet);
            }

            packetsQueue.clear();
        }

        YolBi.instance.getPacketBlinkHandler().stopAll();
        YolBi.instance.getPacketDelayHandler().stopAll();
    }

    @Override
    public void onClientStarted() {
        speedModule = YolBi.instance.getModuleManager().getModule(Speed.class);
    }

    @Listener
    public void onReceive(PacketReceiveEvent event) {
        switch (mode.getValue()) {
            case "Pingspoof":
                if (s08.getValue()) {
                    YolBi.instance.getPacketBlinkHandler().startBlinkingAll();
                    blinking = true;
                    timer.reset();
                }
                break;
            case "Custom":
                if (event.getPacket() instanceof S08PacketPlayerPosLook) {
                    S08PacketPlayerPosLook packet = event.getPacket();

                    if (silentTeleportAccept.getValue() && mc.getNetHandler().doneLoadingTerrain) {
                        if (mc.thePlayer.getDistance(packet.getX(), packet.getY(), packet.getZ()) < silentRange.getValue()) {
                            event.setCancelled(true);
                            PacketUtil.sendPacket(new C03PacketPlayer.C06PacketPlayerPosLook(packet.getX(), packet.getY(), packet.getZ(), packet.getYaw(), packet.getPitch(), false));
                        }
                    }
                }
                break;
        }
    }

    @Listener
    public void onSend(PacketSendEvent event) {
        if (mc.thePlayer == null) return;

        switch (mode.getValue()) {
            case "Custom":
                if (balance.getValue()) {
                    if (event.getPacket() instanceof C03PacketPlayer) {
                        C03PacketPlayer packet = event.getPacket();

                        if (!packet.isMoving() && !packet.getRotating()) {
                            if (mc.thePlayer.posX - mc.thePlayer.lastTickPosX == 0 && mc.thePlayer.posY - mc.thePlayer.lastTickPosY == 0 && mc.thePlayer.posZ - mc.thePlayer.lastTickPosZ == 0) {
                                event.setCancelled(true);
                            }
                        }
                    }
                }
                break;
            case "Watchdog inventory":
                if (event.getPacket() instanceof C16PacketClientStatus || event.getPacket() instanceof C0EPacketClickWindow) {
                    event.setCancelled(true);
                    packetsQueue.add(event.getPacket());
                } else if (event.getPacket() instanceof C0DPacketCloseWindow) {
                    if (!packetsQueue.isEmpty()) {
                        for (Packet packet : packetsQueue) {
                            PacketUtil.sendPacketNoEvent(packet);
                        }

                        packetsQueue.clear();
                    }
                }
                break;
            case "Specte":
                PacketUtil.sendPacketNoEvent(new C18PacketSpectate(mc.thePlayer.getUniqueID()));
        }
    }

    @Listener
    public void onEntityAction(EntityActionEvent event) {
        if (noSprint.getValue()) {
            event.setSprinting(false);
        }

        if (noSneak.getValue()) {
            event.setSneaking(false);
        }
    }

    @Listener
    public void onMove(MoveEvent event) {
        lastMotionX = motionX;
        lastMotionZ = motionZ;

        motionX = event.getX();
        motionZ = event.getZ();
    }

    @Listener
    public void onMotion(MotionEvent event) {
        switch (mode.getValue()) {
            case "Watchdog strafe silent":
                if (mc.thePlayer.ticksExisted < 20) {
                    groundSpoofTicks = ticks = 0;
                }

                boolean usingStrafelessSpeed = speedModule.mode.is("Watchdog") && speedModule.watchdogMode.is("Strafeless");

                if (speedModule.isEnabled() && !usingStrafelessSpeed && !mc.thePlayer.onGround) {
                    if (++ticks >= 2 && mc.thePlayer.fallDistance < 1 && WorldUtil.isBlockUnder(8)) {
                        boolean canGroundSpoof = false;

                        double diff = strict.getValue() ? 0.034 : 0.098;

                        double lastX = lastMotionX * 0.91F;
                        double lastZ = lastMotionZ * 0.91F;

                        if (motionX - lastX > diff) {
                            canGroundSpoof = true;
                        } else if (motionX - lastX < -diff) {
                            canGroundSpoof = true;
                        } else if (motionZ - lastZ > diff) {
                            canGroundSpoof = true;
                        } else if (motionZ - lastZ < -diff) {
                            canGroundSpoof = true;
                        }

                        if (canGroundSpoof) {
                            event.setOnGround(true);

                            if (groundSpoofTicks == 1) {
                                groundSpoofTicks = blinkTicks.getValue() + 1;
                                YolBi.instance.getPacketBlinkHandler().releaseMove();
                                YolBi.instance.getPacketBlinkHandler().releaseOther();
                            } else if (groundSpoofTicks < 1) {
                                groundSpoofTicks = blinkTicks.getValue() + 1;
                            }
                            ticks = 0;

                            YolBi.instance.getPacketBlinkHandler().startBlinkingMove();
                            YolBi.instance.getPacketBlinkHandler().startBlinkingOther();
                            blinking = true;
                        }
                    }
                } else {
                    ticks = 0;
                }

                if (groundSpoofTicks == 1 && blinking) {
                    YolBi.instance.getPacketBlinkHandler().stopAll();
                    blinking = false;
                }

                groundSpoofTicks--;
                break;
            case "Pingspoof":
                if (timer.getTimeElapsed() >= delay.getValue()) {
                    if (blinking) {
                        YolBi.instance.getPacketBlinkHandler().releaseAll();
                        blinking = false;
                    } else {
                        YolBi.instance.getPacketBlinkHandler().releasePing();
                    }

                    timer.reset();
                }

                YolBi.instance.getPacketBlinkHandler().startBlinkingPing();
                break;
        }
    }

    @Override
    public String getSuffix() {
        return mode.getValue();
    }

}
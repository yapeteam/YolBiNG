package cn.yapeteam.yolbi.module.impl.exploit;

import cn.yapeteam.yolbi.YolBi;
import cn.yapeteam.yolbi.event.Listener;
import cn.yapeteam.yolbi.event.Priority;
import cn.yapeteam.yolbi.event.impl.network.PacketReceiveEvent;
import cn.yapeteam.yolbi.event.impl.network.PacketSendEvent;
import cn.yapeteam.yolbi.event.impl.player.EntityActionEvent;
import cn.yapeteam.yolbi.event.impl.player.UpdateEvent;
import cn.yapeteam.yolbi.event.impl.render.Render3DEvent;
import cn.yapeteam.yolbi.module.Module;
import cn.yapeteam.yolbi.module.ModuleCategory;
import cn.yapeteam.yolbi.module.ModuleInfo;
import cn.yapeteam.yolbi.module.impl.movement.Speed;
import cn.yapeteam.yolbi.util.misc.LogUtil;
import cn.yapeteam.yolbi.util.network.PacketUtil;
import cn.yapeteam.yolbi.util.player.RotationsUtil;
import cn.yapeteam.yolbi.util.render.RenderUtil;
import cn.yapeteam.yolbi.values.impl.BooleanValue;
import cn.yapeteam.yolbi.values.impl.ModeValue;
import lombok.Getter;
import lombok.Setter;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.WorldRenderer;
import net.minecraft.client.renderer.entity.RenderManager;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.*;
import net.minecraft.network.play.server.S08PacketPlayerPosLook;

import java.util.ArrayList;
import java.util.concurrent.CopyOnWriteArrayList;

@ModuleInfo(name = "Strafe Converter", category = ModuleCategory.EXPLOIT)
public class StrafeConverter extends Module {
    private final CopyOnWriteArrayList<Packet> packetsQueue = new CopyOnWriteArrayList<>();

    private Speed speedModule;

    private double x, y, z, lastX, lastY, lastZ;

    private double lastGroundX, lastGroundY = -1, lastGroundZ;

    private final BooleanValue allowHittingOffground = new BooleanValue("Allow hitting offground", false);
    private final BooleanValue updateOnVelocity = new BooleanValue("Update on velocity", false);
    private final BooleanValue noSprintSpoof = new BooleanValue("No sprint spoof", false);
    private final ModeValue<String> renderMode = new ModeValue<>("Render mode", "None", "None", "Box", "Line");

    private boolean wasSpeedEnabled;

    private final ArrayList<Position> pastPositions = new ArrayList<>();

    public StrafeConverter() {
        this.addValues(allowHittingOffground, updateOnVelocity, noSprintSpoof, renderMode);
    }

    @Override
    public void onEnable() {
        wasSpeedEnabled = false;

        packetsQueue.clear();
    }

    @Override
    public void onDisable() {
        updatePosition();
    }

    @Override
    public void onClientStarted() {
        speedModule = YolBi.instance.getModuleManager().getModule(Speed.class);
    }

    @Listener(Priority.LOW)
    public void onReceive(PacketReceiveEvent event) {
        if (event.getPacket() instanceof S08PacketPlayerPosLook) {
            if (!packetsQueue.isEmpty()) {
                packetsQueue.stream().filter(p -> !(p instanceof C03PacketPlayer || p instanceof C0BPacketEntityAction)).forEach(PacketUtil::sendPacketFinal);
                packetsQueue.clear();
            }

            if (speedModule.isEnabled()) {
                speedModule.setEnabled(false);
                wasSpeedEnabled = false;
                LogUtil.addChatMessage("Disabled speed due to server teleport.");
            }
        }
    }

    @Listener(Priority.LOW)
    public void onSend(PacketSendEvent event) {
        Packet packet = event.getPacket();

        if (mc.thePlayer == null || mc.thePlayer.ticksExisted < 20) {
            packetsQueue.clear();
        }

        if (speedModule.isEnabled()) {
            if (!event.isCancelled()) {
                boolean shouldNotCancel = allowHittingOffground.getValue() ? packet instanceof C0FPacketConfirmTransaction || packet instanceof C00PacketKeepAlive || packet instanceof C0APacketAnimation || packet instanceof C02PacketUseEntity : packet instanceof C0FPacketConfirmTransaction || packet instanceof C00PacketKeepAlive;

                if (!shouldNotCancel) {
                    event.setCancelled(true);
                    packetsQueue.add(event.getPacket());
                }
            }
        } else {
            this.updatePosition();
        }
    }

    @Listener(Priority.LOW)
    public void onUpdate(UpdateEvent event) {
        if (speedModule.isEnabled() && !wasSpeedEnabled && !mc.thePlayer.onGround) {
            speedModule.setEnabled(false);
            LogUtil.addChatMessage("Disabled speed : you must toggle it on ground to use it with strafe converter.");
        }

        if (!wasSpeedEnabled) {
            lastGroundX = mc.thePlayer.posX;
            lastGroundY = mc.thePlayer.posY;
            lastGroundZ = mc.thePlayer.posZ;
        }

        if (!speedModule.isEnabled() && wasSpeedEnabled) {
            this.updatePosition();

            pastPositions.clear();
        }

        boolean onGround = mc.thePlayer.onGround;

        if (onGround || updateOnVelocity.getValue()) {
            this.updatePosition();

            mc.thePlayer.onGround = onGround;

            lastGroundX = mc.thePlayer.posX;
            lastGroundY = mc.thePlayer.posY;
            lastGroundZ = mc.thePlayer.posZ;
        } else {
            x = mc.thePlayer.posX;
            y = mc.thePlayer.posY;
            z = mc.thePlayer.posZ;
        }

        wasSpeedEnabled = speedModule.isEnabled();
    }

    private void updatePosition() {
        if (!packetsQueue.isEmpty()) {
            if (speedModule == null) {
                speedModule = YolBi.instance.getModuleManager().getModule(Speed.class);
            }

            float direction = RotationsUtil.getRotationsToPosition(lastGroundX, lastGroundY, lastGroundZ, mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ)[0];

            double totalDist = Math.hypot(mc.thePlayer.posX - lastGroundX, mc.thePlayer.posZ - lastGroundZ);

            int moveTicks = getMoveTicks();

            boolean shouldEdit = totalDist > 0;

            int moves = 0;

            mc.thePlayer.setPosition(lastGroundX, lastGroundY, lastGroundZ);

            double lastDist = 0;

            double traveledDist = 0;

            pastPositions.clear();

            for (Packet p : packetsQueue) {
                if (p instanceof C03PacketPlayer && shouldEdit) {
                    C03PacketPlayer packet = (C03PacketPlayer) p;

                    if (moves == 0) {
                        lastX = lastGroundX;
                        lastY = lastGroundY;
                        lastZ = lastGroundZ;
                    } else {
                        lastX = x;
                        lastY = y;
                        lastZ = z;
                    }

                    if (packet.isMoving()) {
                        x = packet.getX();
                        y = packet.getY();
                        z = packet.getZ();

                        double dist = Math.hypot(x - lastX, z - lastZ);

                        if (noSprintSpoof.getValue()) {
                            if (traveledDist > totalDist) {
                                dist = 0;
                            }
                        } else {
                            if (moves >= moveTicks) {
                                dist = lastDist;

                                if (moves == 1 && moveTicks == 1) {
                                    dist *= 0.53;
                                    dist -= 0.026;
                                } else {
                                    dist *= 0.91F;

                                    if (dist > 0.026F) {
                                        dist -= 0.026F * 0.98F;
                                    }
                                }
                            }
                        }

                        double motionX = -Math.sin(Math.toRadians(direction)) * dist;
                        double motionY = y - lastY;
                        double motionZ = Math.cos(Math.toRadians(direction)) * dist;

                        mc.thePlayer.moveEntityNoEvent(motionX, motionY, motionZ);

                        if (packet.getRotating()) {
                            PacketUtil.sendPacketFinal(new C03PacketPlayer.C06PacketPlayerPosLook(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, packet.getYaw(), packet.getPitch(), packet.isOnGround()));
                        } else {
                            PacketUtil.sendPacketFinal(new C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, packet.isOnGround()));
                        }

                        pastPositions.add(new Position(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ));

                        traveledDist += dist;

                        lastDist = dist;
                    } else {
                        lastDist = 0;
                    }

                    moves++;
                } else {
                    PacketUtil.sendPacketFinal(p);
                }
            }

            packetsQueue.clear();
        }
    }

    private int getMoveTicks() {
        if (!packetsQueue.isEmpty()) {
            double totalDist = Math.hypot(mc.thePlayer.posX - lastGroundX, mc.thePlayer.posZ - lastGroundZ);

            ArrayList<Position> positions = new ArrayList<>();

            for (Packet p : packetsQueue) {
                double x = lastGroundX, y = lastGroundY, z = lastGroundZ;

                if (p instanceof C03PacketPlayer) {
                    C03PacketPlayer packet = (C03PacketPlayer) p;

                    if (packet.isMoving()) {
                        x = packet.getX();
                        y = packet.getY();
                        z = packet.getZ();
                    }

                    positions.add(new Position(x, y, z));
                }
            }

            if (!positions.isEmpty()) {
                int stopForwardCount = positions.size();

                while (stopForwardCount > 0) {
                    double currentDist = 0;

                    double lastX = lastGroundX;
                    double lastZ = lastGroundZ;

                    int i = 0;

                    double lastDist = 0;

                    for (Position pos : positions) {
                        double x = pos.getX();
                        double z = pos.getZ();

                        double dist = Math.hypot(x - lastX, z - lastZ);

                        if (i >= stopForwardCount - 1) {
                            dist = lastDist;

                            dist *= 0.91F;

                            if (dist > 0.026F) {
                                dist -= 0.026F * 0.98F;
                            }
                        }

                        currentDist += dist;

                        lastX = x;
                        lastZ = z;

                        lastDist = dist;

                        i++;
                    }

                    if (currentDist <= totalDist) {
                        return stopForwardCount;
                    }

                    stopForwardCount--;
                }
            }
        }

        return 0;
    }

    @Listener
    public void onEntityAction(EntityActionEvent event) {
        if (noSprintSpoof.getValue()) {
            event.setSprinting(false);
        }
    }

    @Listener
    public void onRender3D(Render3DEvent event) {
        if (!renderMode.is("None") && mc.gameSettings.thirdPersonView > 0 && isBlinking()) {
            RenderUtil.prepareBoxRender(3.25F, 1F, 1F, 1F, 0.8F);

            RenderManager rm = mc.getRenderManager();
            float partialTicks = event.getPartialTicks();

            if (renderMode.is("Line")) {
                boolean first = true;

                double previousX = 0, previousY = 0, previousZ = 0;

                if (!pastPositions.isEmpty()) {
                    for (Position pos : pastPositions) {
                        Tessellator tessellator = Tessellator.getInstance();
                        WorldRenderer worldrenderer = tessellator.getWorldRenderer();

                        double renderX = pos.getX() - rm.renderPosX;
                        double renderY = pos.getY() - rm.renderPosY;
                        double renderZ = pos.getZ() - rm.renderPosZ;

                        worldrenderer.begin(3, DefaultVertexFormats.POSITION);

                        if (!first) {
                            worldrenderer.pos(previousX, previousY, previousZ).endVertex();
                            worldrenderer.pos(renderX, renderY, renderZ).endVertex();
                        }

                        tessellator.draw();

                        previousX = renderX;
                        previousY = renderY;
                        previousZ = renderZ;

                        first = false;
                    }
                }
            } else if (renderMode.is("Box")) {
                RenderUtil.renderCustomPlayerBox(rm, partialTicks, lastGroundX, lastGroundY, lastGroundZ);
            }

            RenderUtil.stopBoxRender();
        }
    }

    public boolean isBlinking() {
        return this.isEnabled() && !packetsQueue.isEmpty();
    }

    @Listener
    public int getPriority() {
        return 3;
    }

    private static class Position {
        @Getter
        @Setter
        private double x, y, z;

        private Position(double x, double y, double z) {
            this.x = x;
            this.y = y;
            this.z = z;
        }
    }

}
